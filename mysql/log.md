https://blog.csdn.net/fedorafrog/article/details/112762049

![数据更新](..\mysql\数据更新.png)

## redo log

​	MySQL的数据是存放在磁盘中的，每次读写数据都需做磁盘IO操作，如果并发场景下性能就会很差。为此MySQL提供了一个优化手段，引入缓存**`Buffer Pool`**。这个缓存中包含了磁盘中**部分**数据页（**`page`**）的映射，以此来缓解数据库的磁盘压力。

当从数据库读数据时，首先从缓存中读取，如果缓存中没有，则从磁盘读取后放入缓存；当向数据库写入数据时，先向缓存写入，此时缓存中的数据页数据变更，这个数据页称为**脏页**，**`Buffer Pool`**中修改完数据后会按照设定的更新策略，定期刷到磁盘中，这个过程称为**刷脏页**。

- 用于mysql宕机恢复未持久化数据
- 环状结构，大小固定，两个指针之间数据表示未持久化数据

## undo log

​	主要起到回滚的作用，它是保证事务原子性的关键。记录的是数据修改前的状态，在数据修改的流程中，同时会记录一条与当前操作相反的逻辑日志到**`undo log`**中。

- 回滚

  未提交的事务，即事务未执行`commit`。但该事务内修改的脏页中，可能有一部分脏块已经刷盘。如果此时数据库实例宕机重启，就需要用回滚来将先前那部分已经刷盘的脏块从磁盘上撤销。

- 前滚

  未完全提交的事务，即事务已经执行**`commit`**，但该事务内修改的脏页中只有一部分数据被刷盘，另外一部分还在**`buffer pool`**缓存上，如果此时数据库实例宕机重启，就需要用前滚来完成未完全提交的事务。将先前那部分由于宕机在内存上的未来得及刷盘数据，从**`redo log`**中恢复出来并刷入磁盘。

  > 数据库实例恢复时，先做前滚，后做回滚。

## bin log

**`	bin log`**也被叫做**`归档日志`**，因为它不会像**`redo log`**那样循环写擦除之前的记录，而是会一直记录日志。一个**`bin log`**日志文件默认最大容量`1G`（也可以通过**`max_binlog_size`**参数修改），单个日志超过最大值，则会新创建一个文件继续写